- name: Find argocd app install status
  shell: kubectl --kubeconfig {{ kubeconfig_location }}/kubeconfig -n {{ fact_argocd_helm_namespace }} wait --for=jsonpath='{.status.health.status}'=Healthy --timeout=1m application/{{ fact_argocd_helm_release }}
  register: argocdappexists
  ignore_errors: true

- name: Install argocd
  shell: |
    export KUBECONFIG={{ kubeconfig_location }}/kubeconfig
    helm repo add argo https://argoproj.github.io/argo-helm
    helm repo update
    helm upgrade --install {{ fact_argocd_helm_release }} argo/argo-cd --create-namespace --namespace {{ fact_argocd_helm_namespace }} --version {{ fact_argocd_helm_version }} \
      --set fullnameOverride={{ fact_argocd_helm_release }} \
      --set applicationSet.enabled=false \
      --set notifications.enabled=false \
      --set dex.enabled=false \
      --values {{ cctmpvalues.path }}/argocd/argocd-values.yaml
    kubectl -n {{ fact_argocd_helm_namespace }} rollout status deployment/{{ fact_argocd_helm_release }}-server
  when: argocdappexists is failed

- name: Install root app
  shell: |
    export KUBECONFIG={{ kubeconfig_location }}/kubeconfig
    kubectl apply -f {{ cctmpvalues.path }}/argocd/root-app.yaml

- name: Install utils and wait for argocd autosync
  shell: |
    export KUBECONFIG={{ kubeconfig_location }}/kubeconfig
    export ARGOCD_PWD=$(kubectl -n {{ fact_argocd_helm_namespace }} get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
    until argocd login --core --username admin --password $ARGOCD_PWD --insecure; do :; done
    kubectl config set-context --current --namespace={{ fact_argocd_helm_namespace }}
    until argocd app sync {{ fact_argocd_helm_release }}; do echo "awaiting argocd to sync..." && sleep 10; done
    kubectl -n {{ fact_argocd_helm_namespace }} rollout status deployment/{{ fact_argocd_helm_release }}-repo-server
  args:
    executable: /bin/bash
# - name: Install deploy argo apps
#   shell: |
#     export KUBECONFIG={{ kubeconfig_location }}/kubeconfig
#     kubectl apply -f {{ cctmpvalues.path }}/argocd/vault-app.yaml
#     kubectl apply -f {{ cctmpvalues.path }}/argocd/dns-utils-app.yaml
#     kubectl apply -f {{ cctmpvalues.path }}/argocd/security-app.yaml
#     kubectl apply -f {{ cctmpvalues.path }}/argocd/nexus-app.yaml
#   args:
#     executable: /bin/bash
# - name: Use TF module to perform zitadel netbird config
#   shell: |
#     export KUBECONFIG={{ kubeconfig_location }}/kubeconfig
#     #need to create this ns first so module can write secret to netbird ns
#     kubectl create ns {{ netbird_namespace }} || true
#     kubectl -n {{ netbird_namespace }} apply -f {{ cctmpvalues.path }}/netbird-xplane-terraform.yaml

# - name: Wait for zitadel tf output
#   shell: kubectl --kubeconfig {{ kubeconfig_location }}/kubeconfig get secret -n {{ netbird_namespace }} {{ netbird_preconfig_secret }}
#   register: outputsecret
#   until: outputsecret is not failed
#   retries: 50
#   delay: 10

# - name: Install netbird
#   shell: |
#     export KUBECONFIG={{ kubeconfig_location }}/kubeconfig
#     helm repo add stunner https://l7mp.io/stunner
#     helm upgrade --install stunner stunner/stunner-gateway-operator -n {{ stunner_system_namespace }} --create-namespace
#     kubectl create ns {{ stunner_impl_namespace }} || true
#     kubectl apply -f {{ cctmpvalues.path }}/stunner-crs.yaml
#     kubectl -n {{ netbird_namespace }} apply -f {{ cctmpvalues.path }}/netbird-random-secrets.yaml,{{ cctmpvalues.path }}/netbird-crs.yaml
#     helmfile apply -f {{ cctmpvalues.path }}/netbird-helmfile.yaml
