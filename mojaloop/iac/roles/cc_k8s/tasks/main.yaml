#Create a temporary directory for storing values files or other config
- name: install kubectl
  get_url:
    url: https://storage.googleapis.com/kubernetes-release/release/v{{ kubectl_version }}/bin/linux/amd64/kubectl
    dest: /usr/local/bin/kubectl
    mode: 0700

- name: download kustomize
  ansible.builtin.unarchive:
    src: https://github.com/kubernetes-sigs/kustomize/releases/download/kustomize%2Fv{{ kustomize_version }}/kustomize_v{{ kustomize_version }}_linux_amd64.tar.gz
    dest: /tmp
    remote_src: yes

- name: copy kustomize bin
  copy:
    src: "/tmp/kustomize"
    dest: "/usr/local/bin/kustomize"
    mode: "u+rwx"
    remote_src: yes

- name: download argocd cli
  get_url:
    url: https://github.com/argoproj/argo-cd/releases/download/v{{ argocd_cli_version }}/argocd-linux-amd64
    dest: /usr/local/bin/argocd
    mode: 0700

- name: download helmfile
  ansible.builtin.unarchive:
    src: https://github.com/helmfile/helmfile/releases/download/v{{ helmfile_version }}/helmfile_{{ helmfile_version }}_linux_amd64.tar.gz
    dest: /tmp
    remote_src: yes

- name: copy helmfile bin
  copy:
    src: "/tmp/helmfile"
    dest: "/usr/local/bin/helmfile"
    mode: "u+rwx"
    remote_src: yes

- name: install helm util
  shell: |
    helm plugin install https://github.com/aslafy-z/helm-git --version 0.16.0 || true
    helm plugin install https://github.com/databus23/helm-diff --version 3.9.8 || true

- name: Create temporary directory for cc boot
  tempfile:
    state: directory
    suffix: values
  register: cctmpvalues

- name: "create directory for kubeconfig"
  file:
    path: "{{ kubeconfig_location }}"
    state: directory
    recurse: yes

- name: copy kubeconfig
  copy:
    src: "{{ kubeconfig_local_location }}/kubeconfig"
    dest: "{{ kubeconfig_location }}/kubeconfig"
    mode: "0600"

- name: apply node labels
  shell: |
    kubectl --kubeconfig {{ kubeconfig_location }}/kubeconfig label --overwrite nodes {{ item.node_name }} {% for labels in lookup('dict', item.node_labels, wantlist=True) %} {{ labels.key }}={{ labels.value }}{% endfor %}
  loop: "{{ node_pool_labels }}"
  when: node_pool_labels is defined

- name: apply node taints
  shell: |
    kubectl --kubeconfig {{ kubeconfig_location }}/kubeconfig taint --overwrite nodes {{ item.node_name }} {% for taints in lookup('dict', item.node_taints, wantlist=True) %} {{ taints.value }}{% endfor %}
  loop: "{{ node_pool_taints }}"
  when: node_pool_taints is defined

- name: set argo facts
  set_fact:
    fact_argo_merged_config: "{{ argocd_override | ansible.builtin.combine(argocd_default, recursive=true) }}"
    fact_argocd_helm_namespace: "{{ fact_argo_merged_config.apps[fact_argo_merged_config.argocd_appname].sub_apps['argocd_helm'].namespace }}"
    fact_argocd_helm_release: "{{ fact_argo_merged_config.apps[fact_argo_merged_config.argocd_appname].sub_apps['argocd_helm'].app_name }}"
    fact_argocd_helm_version: "{{ fact_argo_merged_config.apps[fact_argo_merged_config.argocd_appname].sub_apps['argocd_helm'].helm_version }}"

- name: Upload cc template dirs
  file:
    path: "{{ cctmpvalues.path }}/{{ item.path }}"
    state: directory
    mode: "{{ item.mode }}"
  with_filetree: "{{role_path}}/templates/"
  when: item.state == 'directory'

- name: Upload cc template files
  template:
    src: "{{ item.src }}"
    dest: "{{ cctmpvalues.path }}/{{ item.path | regex_replace('\\.j2$', '') }}"
  with_filetree: "{{role_path}}/templates/"
  when: item.state == 'file'

- name: Install argocd
  shell: |
    export KUBECONFIG={{ kubeconfig_location }}/kubeconfig
    helm repo add argo https://argoproj.github.io/argo-helm
    helm repo update
    helm upgrade --install {{ fact_argocd_helm_release }} argo/argo-cd --create-namespace --namespace {{ fact_argocd_helm_namespace }} --version {{ fact_argocd_helm_version }} \
      --set fullnameOverride={{ fact_argocd_helm_release }} \
      --set applicationSet.enabled=false \
      --set notifications.enabled=false \
      --set dex.enabled=false \
      --set configs.cm."kustomize\.buildOptions"="--load-restrictor LoadRestrictionsNone" \
      --set configs.cm."timeout\.reconciliation"="10s"
    kubectl -n {{ fact_argocd_helm_namespace }} rollout status deployment/{{ fact_argocd_helm_release }}-server

- name: Get ArgoCD app yaml
  get_url:
    url: "{{ fact_argo_merged_config.gitrepo_raw_host_fqdn }}/{{ fact_argo_merged_config.gitrepo_owner }}/{{ fact_argo_merged_config.gitrepo_repo }}/{{ fact_argo_merged_config.apps['argocd'].application_gitrepo_tag }}/{{ fact_argo_merged_config.initial_argo_gitrepo_path }}/argocd-helm.yaml"
    dest: "{{ cctmpvalues.path }}/argocd/argoapp.yaml"

- name: Install argocd autosync
  shell: |
    export KUBECONFIG={{ kubeconfig_location }}/kubeconfig
    source {{ cctmpvalues.path }}/argocd/argocd-env.sh
    printf -v argovars "$(cat {{ cctmpvalues.path }}/argocd/argocd-env.txt)"
    cat {{ cctmpvalues.path }}/argocd/argoapp.yaml | envsubst "$(printf "\'$argovars\'")" | kubectl apply -f -
    export ARGOCD_PWD=$(kubectl -n {{ fact_argocd_helm_namespace }} get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
    until argocd login --core --username admin --password $ARGOCD_PWD --insecure; do :; done
    kubectl config set-context --current --namespace={{ fact_argocd_helm_namespace }}
    until argocd app sync {{ fact_argo_merged_config.argocd_appname }}; do echo "awaiting argocd to sync..." && sleep 10; done
    kubectl -n {{ fact_argocd_helm_namespace }} rollout status deployment/{{ fact_argocd_helm_release }}-repo-server
  args:
    executable: /bin/bash
- name: Install root app
  shell: |
    export KUBECONFIG={{ kubeconfig_location }}/kubeconfig
  #  kubectl apply -f {{ cctmpvalues.path }}/argocd/root-app.yaml

# - name: Install utils
#   shell: |
#     export KUBECONFIG={{ kubeconfig_location }}/kubeconfig
#     kustomize build --enable-helm {{ cctmpvalues.path }}/utils > /tmp/utils-deploy.yaml
#     kubectl apply -f /tmp/utils-deploy.yaml
#     while true;do
#       kubectl wait -n {{ certmanager_namespace }} --for=jsonpath='{.status.succeeded}'=1 job/cert-manager-startupapicheck && break
#       sleep 5
#     done
#     while true;do
#       kubectl wait -n {{ crossplane_namespace }} --for=jsonpath='{.status.readyReplicas}'=1 deployment/crossplane && break
#       sleep 5
#     done
#     while true;do
#       kubectl wait -n {{ istio_namespace }} --for=jsonpath='{.status.readyReplicas}'=1 deployment/istiod && break
#       sleep 5
#     done
#     while true;do
#       kubectl wait -n {{ rook_ceph_namespace }} --for=jsonpath='{.status.readyReplicas}'=1 deployment/rook-ceph-operator && break
#       sleep 5
#     done
#     kustomize build --enable-helm {{ cctmpvalues.path }}/utils/crs > /tmp/utils-crs-deploy.yaml
#     kubectl apply -f /tmp/utils-crs-deploy.yaml

# - name: Wait for blockpool
#   shell: kubectl --kubeconfig {{ kubeconfig_location }}/kubeconfig -n {{ rook_ceph_namespace }} wait --for=jsonpath='{.status.phase}'=Ready --timeout=10m CephBlockPool/ceph-blockpool
#   register: blockpool
#   until: blockpool is not failed
#   retries: 50
#   delay: 10

# - name: Install zitadel
#   shell: |
#     export KUBECONFIG={{ kubeconfig_location }}/kubeconfig
#     kustomize build --enable-helm {{ cctmpvalues.path }}/zitadel > /tmp/zitadel-deploy.yaml
#     kubectl apply -f /tmp/zitadel-deploy.yaml

# - name: Wait for zitadel key
#   shell: kubectl --kubeconfig {{ kubeconfig_location }}/kubeconfig get secret -n {{ zitadel_namespace }} zitadel-admin-sa -o jsonpath='{.data.zitadel-admin-sa\.json}' | base64 -d
#   register: adminkey
#   until: adminkey is not failed
#   retries: 50
#   delay: 10
# - name: Use zitadel TF module to perform zitadel init
#   shell: |
#     export KUBECONFIG={{ kubeconfig_location }}/kubeconfig
#     kubectl -n {{ zitadel_namespace }} apply -f {{ cctmpvalues.path }}/zitadel-xplane-terraform.yaml

# - name: Install vault
#   shell: |
#     export KUBECONFIG={{ kubeconfig_location }}/kubeconfig
#     helm repo add hashicorp https://helm.releases.hashicorp.com
#     kubectl apply -f {{ cctmpvalues.path }}/vault-crs.yaml
#     helm upgrade --install consul hashicorp/consul --version {{ consul_helm_version }} -n {{ consul_namespace }} --create-namespace --values {{ cctmpvalues.path }}/consul-values.yaml
#
#     helm upgrade --install vault hashicorp/vault --version {{ vault_helm_version }} -n {{ vault_namespace }} --values {{ cctmpvalues.path }}/vault-values.yaml
#     kubectl apply -f {{ cctmpvalues.path }}/vault-xplane-terraform.yaml

# - name: Use TF module to perform zitadel netbird config
#   shell: |
#     export KUBECONFIG={{ kubeconfig_location }}/kubeconfig
#     #need to create this ns first so module can write secret to netbird ns
#     kubectl create ns {{ netbird_namespace }} || true
#     kubectl -n {{ netbird_namespace }} apply -f {{ cctmpvalues.path }}/netbird-xplane-terraform.yaml

# - name: Wait for zitadel tf output
#   shell: kubectl --kubeconfig {{ kubeconfig_location }}/kubeconfig get secret -n {{ netbird_namespace }} {{ netbird_preconfig_secret }}
#   register: outputsecret
#   until: outputsecret is not failed
#   retries: 50
#   delay: 10

# - name: Install netbird
#   shell: |
#     export KUBECONFIG={{ kubeconfig_location }}/kubeconfig
#     helm repo add stunner https://l7mp.io/stunner
#     helm upgrade --install stunner stunner/stunner-gateway-operator -n {{ stunner_system_namespace }} --create-namespace
#     kubectl create ns {{ stunner_impl_namespace }} || true
#     kubectl apply -f {{ cctmpvalues.path }}/stunner-crs.yaml
#     kubectl -n {{ netbird_namespace }} apply -f {{ cctmpvalues.path }}/netbird-random-secrets.yaml,{{ cctmpvalues.path }}/netbird-crs.yaml
#     helmfile apply -f {{ cctmpvalues.path }}/netbird-helmfile.yaml
